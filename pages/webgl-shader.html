<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Shaders - Karmakazi</title>
    <link rel="stylesheet" href="../styles/main.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #6b73ff 0%, #000dff 100%);
            min-height: 100vh;
            font-family: 'Inter', sans-serif;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            padding: 2rem 0;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 10;
        }
        
        .title {
            font-size: clamp(2rem, 6vw, 4rem);
            font-weight: 700;
            color: white;
            text-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            margin-bottom: 1rem;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 2rem;
        }
        
        /* Demo Container */
        .demo-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 3rem;
            padding: 3rem;
            max-width: 1600px;
            margin: 0 auto;
        }
        
        .demo-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-height: 450px;
        }
        
        .demo-title {
            font-size: 1.5rem;
            color: white;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        /* Canvas Container */
        .canvas-container {
            width: 100%;
            height: 350px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            cursor: crosshair;
            margin: 1rem 0;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 15px;
        }
        
        /* Controls */
        .controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .control-btn {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .control-btn.active {
            background: white;
            color: #000dff;
        }
        
        /* Slider Controls */
        .slider-control {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            color: white;
        }
        
        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
        }
        
        /* Info Text */
        .info {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85rem;
            text-align: center;
            margin-top: 0.5rem;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .demo-container {
                grid-template-columns: 1fr;
                padding: 1rem;
            }
            
            .canvas-container {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">WebGL Shaders</h1>
        <p class="subtitle">Advanced GPU-powered visual effects using GLSL shaders</p>
    </div>

    <div class="demo-container">
        <!-- Fractal Noise -->
        <div class="demo-card">
            <h3 class="demo-title">Fractal Noise</h3>
            <div class="canvas-container">
                <canvas id="fractalCanvas"></canvas>
            </div>
            <div class="controls">
                <button class="control-btn active" onclick="setFractalType('perlin')">Perlin</button>
                <button class="control-btn" onclick="setFractalType('simplex')">Simplex</button>
                <button class="control-btn" onclick="setFractalType('voronoi')">Voronoi</button>
                <button class="control-btn" onclick="setFractalType('turbulence')">Turbulence</button>
            </div>
            <div class="slider-control">
                <span>Octaves:</span>
                <input type="range" class="slider" min="1" max="8" value="4" 
                       onchange="setFractalOctaves(this.value)" id="fractalOctaves">
                <span id="fractalOctavesValue">4</span>
            </div>
            <p class="info">Move mouse to control zoom and rotation</p>
        </div>

        <!-- Plasma Effect -->
        <div class="demo-card">
            <h3 class="demo-title">Plasma Effect</h3>
            <div class="canvas-container">
                <canvas id="plasmaCanvas"></canvas>
            </div>
            <div class="controls">
                <button class="control-btn active" onclick="setPlasmaMode('classic')">Classic</button>
                <button class="control-btn" onclick="setPlasmaMode('electric')">Electric</button>
                <button class="control-btn" onclick="setPlasmaMode('fire')">Fire</button>
                <button class="control-btn" onclick="setPlasmaMode('ocean')">Ocean</button>
            </div>
            <div class="slider-control">
                <span>Speed:</span>
                <input type="range" class="slider" min="0.5" max="3" step="0.1" value="1" 
                       onchange="setPlasmaSpeed(this.value)" id="plasmaSpeed">
                <span id="plasmaSpeedValue">1.0</span>
            </div>
        </div>

        <!-- Wave Distortion -->
        <div class="demo-card">
            <h3 class="demo-title">Wave Distortion</h3>
            <div class="canvas-container">
                <canvas id="waveCanvas"></canvas>
            </div>
            <div class="controls">
                <button class="control-btn active" onclick="setWavePattern('sine')">Sine</button>
                <button class="control-btn" onclick="setWavePattern('circular')">Circular</button>
                <button class="control-btn" onclick="setWavePattern('spiral')">Spiral</button>
                <button class="control-btn" onclick="setWavePattern('ripple')">Ripple</button>
            </div>
            <div class="slider-control">
                <span>Amplitude:</span>
                <input type="range" class="slider" min="10" max="100" value="50" 
                       onchange="setWaveAmplitude(this.value)" id="waveAmp">
                <span id="waveAmpValue">50</span>
            </div>
        </div>

        <!-- Particle Field -->
        <div class="demo-card">
            <h3 class="demo-title">Particle Field</h3>
            <div class="canvas-container">
                <canvas id="particleCanvas"></canvas>
            </div>
            <div class="controls">
                <button class="control-btn active" onclick="setParticleMode('flow')">Flow</button>
                <button class="control-btn" onclick="setParticleMode('attract')">Attract</button>
                <button class="control-btn" onclick="setParticleMode('repel')">Repel</button>
                <button class="control-btn" onclick="setParticleMode('orbit')">Orbit</button>
            </div>
            <div class="slider-control">
                <span>Particles:</span>
                <input type="range" class="slider" min="1000" max="10000" step="1000" value="5000" 
                       onchange="setParticleCount(this.value)" id="particleCount">
                <span id="particleCountValue">5000</span>
            </div>
            <p class="info">Click to create attraction points</p>
        </div>

        <!-- Metaballs -->
        <div class="demo-card">
            <h3 class="demo-title">Metaballs</h3>
            <div class="canvas-container">
                <canvas id="metaballCanvas"></canvas>
            </div>
            <div class="controls">
                <button class="control-btn active" onclick="setMetaballStyle('liquid')">Liquid</button>
                <button class="control-btn" onclick="setMetaballStyle('glow')">Glow</button>
                <button class="control-btn" onclick="setMetaballStyle('neon')">Neon</button>
                <button class="control-btn" onclick="setMetaballStyle('chrome')">Chrome</button>
            </div>
            <div class="slider-control">
                <span>Threshold:</span>
                <input type="range" class="slider" min="0.3" max="1.5" step="0.1" value="1" 
                       onchange="setMetaballThreshold(this.value)" id="metaThreshold">
                <span id="metaThresholdValue">1.0</span>
            </div>
        </div>

        <!-- Kaleidoscope -->
        <div class="demo-card">
            <h3 class="demo-title">Kaleidoscope</h3>
            <div class="canvas-container">
                <canvas id="kaleidoCanvas"></canvas>
            </div>
            <div class="controls">
                <button class="control-btn active" onclick="setKaleidoSegments(6)">6 Segments</button>
                <button class="control-btn" onclick="setKaleidoSegments(8)">8 Segments</button>
                <button class="control-btn" onclick="setKaleidoSegments(12)">12 Segments</button>
                <button class="control-btn" onclick="setKaleidoSegments(16)">16 Segments</button>
            </div>
            <div class="slider-control">
                <span>Rotation:</span>
                <input type="range" class="slider" min="0" max="2" step="0.1" value="0.5" 
                       onchange="setKaleidoRotation(this.value)" id="kaleidoRot">
                <span id="kaleidoRotValue">0.5</span>
            </div>
        </div>

        <!-- Ray Marching -->
        <div class="demo-card">
            <h3 class="demo-title">Ray Marching</h3>
            <div class="canvas-container">
                <canvas id="raymarchCanvas"></canvas>
            </div>
            <div class="controls">
                <button class="control-btn active" onclick="setRaymarchScene('spheres')">Spheres</button>
                <button class="control-btn" onclick="setRaymarchScene('torus')">Torus</button>
                <button class="control-btn" onclick="setRaymarchScene('mandelbulb')">Mandelbulb</button>
                <button class="control-btn" onclick="setRaymarchScene('menger')">Menger</button>
            </div>
            <div class="slider-control">
                <span>Detail:</span>
                <input type="range" class="slider" min="16" max="128" step="16" value="64" 
                       onchange="setRaymarchSteps(this.value)" id="raymarchSteps">
                <span id="raymarchStepsValue">64</span>
            </div>
        </div>

        <!-- Color Gradient -->
        <div class="demo-card">
            <h3 class="demo-title">Dynamic Gradients</h3>
            <div class="canvas-container">
                <canvas id="gradientCanvas"></canvas>
            </div>
            <div class="controls">
                <button class="control-btn active" onclick="setGradientType('rainbow')">Rainbow</button>
                <button class="control-btn" onclick="setGradientType('sunset')">Sunset</button>
                <button class="control-btn" onclick="setGradientType('aurora')">Aurora</button>
                <button class="control-btn" onclick="setGradientType('galaxy')">Galaxy</button>
            </div>
            <div class="slider-control">
                <span>Complexity:</span>
                <input type="range" class="slider" min="2" max="10" value="5" 
                       onchange="setGradientComplexity(this.value)" id="gradComplex">
                <span id="gradComplexValue">5</span>
            </div>
        </div>
    </div>

    <script>
        // WebGL Shader utilities
        class ShaderProgram {
            constructor(canvas, vertexSource, fragmentSource) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                
                if (!this.gl) {
                    console.error('WebGL not supported');
                    return;
                }
                
                this.program = this.createProgram(vertexSource, fragmentSource);
                this.uniforms = {};
                this.time = 0;
                this.mouse = { x: 0.5, y: 0.5 };
                
                this.setupCanvas();
                this.setupGeometry();
                this.setupMouseTracking();
            }
            
            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', this.gl.getShaderInfoLog(shader));
                    this.gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            createProgram(vertexSource, fragmentSource) {
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);
                
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);
                
                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Program linking error:', this.gl.getProgramInfoLog(program));
                    return null;
                }
                
                return program;
            }
            
            setupCanvas() {
                const resize = () => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.canvas.width = rect.width * window.devicePixelRatio;
                    this.canvas.height = rect.height * window.devicePixelRatio;
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                };
                
                resize();
                window.addEventListener('resize', resize);
            }
            
            setupGeometry() {
                const vertices = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1
                ]);
                
                const buffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
                
                const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
                this.gl.enableVertexAttribArray(positionLocation);
                this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
            }
            
            setupMouseTracking() {
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });
            }
            
            setUniform(name, value) {
                this.uniforms[name] = value;
            }
            
            render() {
                this.gl.useProgram(this.program);
                
                // Set time uniform
                const timeLocation = this.gl.getUniformLocation(this.program, 'u_time');
                this.gl.uniform1f(timeLocation, this.time);
                
                // Set resolution uniform
                const resolutionLocation = this.gl.getUniformLocation(this.program, 'u_resolution');
                this.gl.uniform2f(resolutionLocation, this.canvas.width, this.canvas.height);
                
                // Set mouse uniform
                const mouseLocation = this.gl.getUniformLocation(this.program, 'u_mouse');
                this.gl.uniform2f(mouseLocation, this.mouse.x, this.mouse.y);
                
                // Set custom uniforms
                for (const [name, value] of Object.entries(this.uniforms)) {
                    const location = this.gl.getUniformLocation(this.program, name);
                    if (Array.isArray(value)) {
                        if (value.length === 2) {
                            this.gl.uniform2f(location, value[0], value[1]);
                        } else if (value.length === 3) {
                            this.gl.uniform3f(location, value[0], value[1], value[2]);
                        } else if (value.length === 4) {
                            this.gl.uniform4f(location, value[0], value[1], value[2], value[3]);
                        }
                    } else {
                        this.gl.uniform1f(location, value);
                    }
                }
                
                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
                this.time += 0.01;
            }
        }

        // Vertex shader (same for all effects)
        const vertexShader = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Fractal Noise shader
        const fractalShader = `
            precision mediump float;
            
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_octaves;
            uniform float u_type;
            
            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }
            
            float noise(vec2 st) {
                vec2 i = floor(st);
                vec2 f = fract(st);
                
                float a = random(i);
                float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0));
                float d = random(i + vec2(1.0, 1.0));
                
                vec2 u = f * f * (3.0 - 2.0 * f);
                
                return mix(a, b, u.x) +
                        (c - a)* u.y * (1.0 - u.x) +
                        (d - b) * u.x * u.y;
            }
            
            float fbm(vec2 st, float octaves) {
                float value = 0.0;
                float amplitude = 0.5;
                float frequency = 0.0;
                
                for(int i = 0; i < 8; i++) {
                    if(float(i) >= octaves) break;
                    value += amplitude * noise(st);
                    st *= 2.0;
                    amplitude *= 0.5;
                }
                
                return value;
            }
            
            void main() {
                vec2 st = gl_FragCoord.xy / u_resolution.xy;
                st.x *= u_resolution.x / u_resolution.y;
                
                vec2 mouse = u_mouse / u_resolution.xy;
                float zoom = 3.0 + mouse.x * 5.0;
                float rotation = mouse.y * 6.28318;
                
                mat2 rot = mat2(cos(rotation), -sin(rotation),
                               sin(rotation), cos(rotation));
                st = rot * (st - 0.5) * zoom;
                st += vec2(u_time * 0.1);
                
                vec3 color = vec3(0.0);
                
                float n = fbm(st + u_time * 0.1, u_octaves);
                
                if(u_type < 0.5) {
                    // Perlin noise
                    color = vec3(n);
                } else if(u_type < 1.5) {
                    // Simplex-like
                    color = vec3(n * 0.5 + 0.5);
                    color = mix(color, vec3(0.2, 0.5, 1.0), n);
                } else if(u_type < 2.5) {
                    // Voronoi-like
                    float n2 = fbm(st * 2.0 + 10.0, u_octaves);
                    color = vec3(step(0.5, n) * n2);
                } else {
                    // Turbulence
                    color = vec3(abs(n * 2.0 - 1.0));
                }
                
                color = mix(color, vec3(0.1, 0.2, 0.8), 0.2);
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Plasma shader
        const plasmaShader = `
            precision mediump float;
            
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform float u_speed;
            uniform float u_mode;
            
            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                float t = u_time * u_speed;
                
                vec3 color = vec3(0.0);
                
                for(float i = 1.0; i < 10.0; i++) {
                    uv.x += 0.1 / i * sin(i * 2.5 * uv.y + t);
                    uv.y += 0.1 / i * cos(i * 1.5 * uv.x + t);
                }
                
                if(u_mode < 0.5) {
                    // Classic plasma
                    color = vec3(0.5 * sin(3.0 * uv.x) + 0.5,
                                0.5 * sin(3.0 * uv.y) + 0.5,
                                sin(uv.x + uv.y));
                } else if(u_mode < 1.5) {
                    // Electric
                    color = vec3(sin(uv.x * 5.0),
                                sin(uv.y * 5.0),
                                1.0);
                } else if(u_mode < 2.5) {
                    // Fire
                    color = vec3(1.0,
                                0.5 * sin(3.0 * uv.y) + 0.5,
                                0.2);
                } else {
                    // Ocean
                    color = vec3(0.0,
                                0.5 * sin(3.0 * uv.y) + 0.5,
                                1.0);
                }
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Wave distortion shader
        const waveShader = `
            precision mediump float;
            
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_amplitude;
            uniform float u_pattern;
            
            void main() {
                vec2 st = gl_FragCoord.xy / u_resolution.xy;
                vec2 center = vec2(0.5);
                
                float dist = distance(st, center);
                float angle = atan(st.y - center.y, st.x - center.x);
                
                vec3 color = vec3(0.0);
                
                if(u_pattern < 0.5) {
                    // Sine waves
                    float wave = sin(dist * u_amplitude - u_time * 2.0);
                    color = vec3(wave);
                } else if(u_pattern < 1.5) {
                    // Circular waves
                    float wave = sin(dist * u_amplitude - u_time * 3.0);
                    color = vec3(wave * st.x, wave * st.y, wave);
                } else if(u_pattern < 2.5) {
                    // Spiral
                    float spiral = sin(dist * u_amplitude - angle * 5.0 - u_time * 2.0);
                    color = vec3(spiral);
                } else {
                    // Ripple
                    vec2 mouse = u_mouse / u_resolution.xy;
                    float mdist = distance(st, mouse);
                    float ripple = sin(mdist * u_amplitude - u_time * 5.0) / (mdist * 10.0 + 1.0);
                    color = vec3(ripple + 0.5);
                }
                
                color = abs(color);
                color = mix(color, vec3(0.2, 0.4, 0.8), 0.3);
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Particle field shader
        const particleShader = `
            precision mediump float;
            
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_count;
            uniform float u_mode;
            
            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }
            
            void main() {
                vec2 st = gl_FragCoord.xy / u_resolution.xy;
                vec2 mouse = u_mouse / u_resolution.xy;
                
                float minDist = 1.0;
                vec3 color = vec3(0.0);
                
                for(float i = 0.0; i < 100.0; i++) {
                    if(i >= u_count / 100.0) break;
                    
                    vec2 seed = vec2(i * 0.1, i * 0.13);
                    vec2 pos = vec2(random(seed), random(seed + 0.1));
                    
                    if(u_mode < 0.5) {
                        // Flow
                        pos.x += sin(u_time + i * 0.1) * 0.1;
                        pos.y += cos(u_time + i * 0.1) * 0.1;
                    } else if(u_mode < 1.5) {
                        // Attract to mouse
                        vec2 toMouse = mouse - pos;
                        pos += toMouse * 0.3 * sin(u_time);
                    } else if(u_mode < 2.5) {
                        // Repel from mouse
                        vec2 fromMouse = pos - mouse;
                        float dist = length(fromMouse);
                        pos += normalize(fromMouse) * 0.1 / (dist + 0.1);
                    } else {
                        // Orbit
                        float angle = atan(pos.y - 0.5, pos.x - 0.5);
                        angle += u_time * 0.5;
                        float radius = distance(pos, vec2(0.5));
                        pos = vec2(0.5) + vec2(cos(angle), sin(angle)) * radius;
                    }
                    
                    float dist = distance(st, pos);
                    if(dist < minDist) {
                        minDist = dist;
                        color = vec3(1.0 - dist * 10.0);
                    }
                }
                
                color *= vec3(0.5, 0.7, 1.0);
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Metaballs shader
        const metaballShader = `
            precision mediump float;
            
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform float u_threshold;
            uniform float u_style;
            
            float metaball(vec2 p, vec2 center, float radius) {
                float dist = distance(p, center);
                return radius / (dist * dist + 0.01);
            }
            
            void main() {
                vec2 st = gl_FragCoord.xy / u_resolution.xy;
                
                float value = 0.0;
                
                // Add multiple metaballs
                value += metaball(st, vec2(0.5 + sin(u_time) * 0.3, 0.5 + cos(u_time) * 0.3), 0.05);
                value += metaball(st, vec2(0.5 + cos(u_time * 1.3) * 0.3, 0.5 + sin(u_time * 1.3) * 0.3), 0.03);
                value += metaball(st, vec2(0.5 + sin(u_time * 0.7) * 0.2, 0.5 - cos(u_time * 0.7) * 0.2), 0.04);
                value += metaball(st, vec2(0.5 - cos(u_time * 0.9) * 0.25, 0.5 + sin(u_time * 0.9) * 0.25), 0.035);
                value += metaball(st, vec2(0.5, 0.5), 0.02);
                
                vec3 color;
                
                if(u_style < 0.5) {
                    // Liquid
                    float threshold = step(u_threshold, value);
                    color = vec3(threshold) * vec3(0.4, 0.6, 1.0);
                } else if(u_style < 1.5) {
                    // Glow
                    color = vec3(value * 0.5) * vec3(1.0, 0.8, 0.5);
                } else if(u_style < 2.5) {
                    // Neon
                    float edge = abs(value - u_threshold) < 0.1 ? 1.0 : 0.0;
                    color = vec3(edge) * vec3(1.0, 0.0, 1.0);
                } else {
                    // Chrome
                    float chrome = sin(value * 10.0) * 0.5 + 0.5;
                    color = vec3(chrome);
                }
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Kaleidoscope shader
        const kaleidoShader = `
            precision mediump float;
            
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform float u_segments;
            uniform float u_rotation;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            void main() {
                vec2 st = gl_FragCoord.xy / u_resolution.xy;
                st = st * 2.0 - 1.0;
                st.x *= u_resolution.x / u_resolution.y;
                
                float angle = atan(st.y, st.x) + u_time * u_rotation;
                float radius = length(st);
                
                angle = mod(angle, 6.28318 / u_segments);
                angle = abs(angle - 3.14159 / u_segments);
                
                st = vec2(cos(angle), sin(angle)) * radius;
                
                vec3 color = hsv2rgb(vec3(
                    st.x * 0.5 + 0.5 + u_time * 0.1,
                    1.0,
                    st.y * 0.5 + 0.5
                ));
                
                color *= 1.0 - radius * 0.3;
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Ray marching shader
        const raymarchShader = `
            precision mediump float;
            
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_steps;
            uniform float u_scene;
            
            float sdSphere(vec3 p, float r) {
                return length(p) - r;
            }
            
            float sdTorus(vec3 p, vec2 t) {
                vec2 q = vec2(length(p.xz) - t.x, p.y);
                return length(q) - t.y;
            }
            
            float sdBox(vec3 p, vec3 b) {
                vec3 q = abs(p) - b;
                return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
            }
            
            float map(vec3 p) {
                float d = 1000.0;
                
                if(u_scene < 0.5) {
                    // Spheres
                    d = min(d, sdSphere(p - vec3(sin(u_time), 0.0, 0.0), 0.5));
                    d = min(d, sdSphere(p + vec3(sin(u_time), 0.0, 0.0), 0.5));
                    d = min(d, sdSphere(p - vec3(0.0, cos(u_time), 0.0), 0.3));
                } else if(u_scene < 1.5) {
                    // Torus
                    vec3 q = p;
                    q.xz = mat2(cos(u_time), -sin(u_time), sin(u_time), cos(u_time)) * q.xz;
                    d = sdTorus(q, vec2(0.6, 0.2));
                } else if(u_scene < 2.5) {
                    // Mandelbulb approximation
                    vec3 z = p;
                    float dr = 1.0;
                    float r = 0.0;
                    for(int i = 0; i < 4; i++) {
                        r = length(z);
                        if(r > 2.0) break;
                        
                        float theta = acos(z.z / r);
                        float phi = atan(z.y, z.x);
                        dr = pow(r, 7.0) * 8.0 * dr + 1.0;
                        
                        float zr = pow(r, 8.0);
                        theta = theta * 8.0;
                        phi = phi * 8.0;
                        
                        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
                        z += p;
                    }
                    d = 0.5 * log(r) * r / dr;
                } else {
                    // Menger sponge approximation
                    float s = 1.0;
                    vec3 q = p;
                    for(int i = 0; i < 3; i++) {
                        q = mod(q, 2.0) - 1.0;
                        s *= 3.0;
                        q = abs(q);
                        q = q.zyx;
                    }
                    d = (sdBox(q, vec3(1.0)) / s);
                }
                
                return d;
            }
            
            vec3 getNormal(vec3 p) {
                vec2 e = vec2(0.001, 0.0);
                return normalize(vec3(
                    map(p + e.xyy) - map(p - e.xyy),
                    map(p + e.yxy) - map(p - e.yxy),
                    map(p + e.yyx) - map(p - e.yyx)
                ));
            }
            
            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;
                vec2 mouse = (u_mouse - 0.5 * u_resolution.xy) / u_resolution.y;
                
                vec3 ro = vec3(0.0, 0.0, -3.0);
                ro.xz = mat2(cos(mouse.x * 3.14), -sin(mouse.x * 3.14), 
                            sin(mouse.x * 3.14), cos(mouse.x * 3.14)) * ro.xz;
                
                vec3 rd = normalize(vec3(uv, 1.0));
                
                float t = 0.0;
                vec3 col = vec3(0.0);
                
                for(int i = 0; i < 128; i++) {
                    if(float(i) >= u_steps) break;
                    
                    vec3 p = ro + rd * t;
                    float d = map(p);
                    
                    if(d < 0.001) {
                        vec3 n = getNormal(p);
                        vec3 light = normalize(vec3(1.0, 1.0, -1.0));
                        float diff = max(dot(n, light), 0.0);
                        col = vec3(diff) * vec3(0.5, 0.7, 1.0);
                        break;
                    }
                    
                    t += d;
                    if(t > 20.0) break;
                }
                
                col = mix(col, vec3(0.1, 0.1, 0.2), t / 20.0);
                
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // Dynamic gradient shader
        const gradientShader = `
            precision mediump float;
            
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform float u_complexity;
            uniform float u_type;
            
            vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {
                return a + b * cos(6.28318 * (c * t + d));
            }
            
            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                
                vec3 color = vec3(0.0);
                
                for(float i = 0.0; i < 10.0; i++) {
                    if(i >= u_complexity) break;
                    
                    vec2 p = uv * 2.0 - 1.0;
                    p.x *= u_resolution.x / u_resolution.y;
                    
                    float angle = u_time * 0.2 * (i + 1.0);
                    p = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * p;
                    
                    float d = length(p) * exp(-length(p));
                    
                    if(u_type < 0.5) {
                        // Rainbow
                        vec3 col = palette(
                            d + u_time * 0.1 + i * 0.1,
                            vec3(0.5), vec3(0.5), vec3(1.0), vec3(0.0, 0.1, 0.2)
                        );
                        color += col / u_complexity;
                    } else if(u_type < 1.5) {
                        // Sunset
                        vec3 col = palette(
                            d + u_time * 0.1 + i * 0.1,
                            vec3(0.5), vec3(0.5), vec3(1.0), vec3(0.3, 0.2, 0.2)
                        );
                        color += col / u_complexity * vec3(1.0, 0.5, 0.3);
                    } else if(u_type < 2.5) {
                        // Aurora
                        vec3 col = palette(
                            d + u_time * 0.1 + i * 0.1,
                            vec3(0.5), vec3(0.5), vec3(1.0), vec3(0.0, 0.3, 0.2)
                        );
                        color += col / u_complexity * vec3(0.3, 1.0, 0.5);
                    } else {
                        // Galaxy
                        vec3 col = palette(
                            d + u_time * 0.1 + i * 0.1,
                            vec3(0.5), vec3(0.5), vec3(1.0), vec3(0.1, 0.0, 0.3)
                        );
                        color += col / u_complexity * vec3(0.5, 0.3, 1.0);
                    }
                }
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Initialize shader programs
        let shaders = {};
        
        function initShaders() {
            // Fractal noise
            const fractalCanvas = document.getElementById('fractalCanvas');
            shaders.fractal = new ShaderProgram(fractalCanvas, vertexShader, fractalShader);
            shaders.fractal.setUniform('u_octaves', 4);
            shaders.fractal.setUniform('u_type', 0);
            
            // Plasma
            const plasmaCanvas = document.getElementById('plasmaCanvas');
            shaders.plasma = new ShaderProgram(plasmaCanvas, vertexShader, plasmaShader);
            shaders.plasma.setUniform('u_speed', 1);
            shaders.plasma.setUniform('u_mode', 0);
            
            // Wave distortion
            const waveCanvas = document.getElementById('waveCanvas');
            shaders.wave = new ShaderProgram(waveCanvas, vertexShader, waveShader);
            shaders.wave.setUniform('u_amplitude', 50);
            shaders.wave.setUniform('u_pattern', 0);
            
            // Particle field
            const particleCanvas = document.getElementById('particleCanvas');
            shaders.particle = new ShaderProgram(particleCanvas, vertexShader, particleShader);
            shaders.particle.setUniform('u_count', 50);
            shaders.particle.setUniform('u_mode', 0);
            
            // Metaballs
            const metaballCanvas = document.getElementById('metaballCanvas');
            shaders.metaball = new ShaderProgram(metaballCanvas, vertexShader, metaballShader);
            shaders.metaball.setUniform('u_threshold', 1);
            shaders.metaball.setUniform('u_style', 0);
            
            // Kaleidoscope
            const kaleidoCanvas = document.getElementById('kaleidoCanvas');
            shaders.kaleido = new ShaderProgram(kaleidoCanvas, vertexShader, kaleidoShader);
            shaders.kaleido.setUniform('u_segments', 6);
            shaders.kaleido.setUniform('u_rotation', 0.5);
            
            // Ray marching
            const raymarchCanvas = document.getElementById('raymarchCanvas');
            shaders.raymarch = new ShaderProgram(raymarchCanvas, vertexShader, raymarchShader);
            shaders.raymarch.setUniform('u_steps', 64);
            shaders.raymarch.setUniform('u_scene', 0);
            
            // Gradient
            const gradientCanvas = document.getElementById('gradientCanvas');
            shaders.gradient = new ShaderProgram(gradientCanvas, vertexShader, gradientShader);
            shaders.gradient.setUniform('u_complexity', 5);
            shaders.gradient.setUniform('u_type', 0);
        }

        // Control functions
        function setFractalType(type) {
            const types = { perlin: 0, simplex: 1, voronoi: 2, turbulence: 3 };
            shaders.fractal.setUniform('u_type', types[type]);
            updateActiveButton(event.target);
        }

        function setFractalOctaves(value) {
            shaders.fractal.setUniform('u_octaves', parseFloat(value));
            document.getElementById('fractalOctavesValue').textContent = value;
        }

        function setPlasmaMode(mode) {
            const modes = { classic: 0, electric: 1, fire: 2, ocean: 3 };
            shaders.plasma.setUniform('u_mode', modes[mode]);
            updateActiveButton(event.target);
        }

        function setPlasmaSpeed(value) {
            shaders.plasma.setUniform('u_speed', parseFloat(value));
            document.getElementById('plasmaSpeedValue').textContent = value;
        }

        function setWavePattern(pattern) {
            const patterns = { sine: 0, circular: 1, spiral: 2, ripple: 3 };
            shaders.wave.setUniform('u_pattern', patterns[pattern]);
            updateActiveButton(event.target);
        }

        function setWaveAmplitude(value) {
            shaders.wave.setUniform('u_amplitude', parseFloat(value));
            document.getElementById('waveAmpValue').textContent = value;
        }

        function setParticleMode(mode) {
            const modes = { flow: 0, attract: 1, repel: 2, orbit: 3 };
            shaders.particle.setUniform('u_mode', modes[mode]);
            updateActiveButton(event.target);
        }

        function setParticleCount(value) {
            shaders.particle.setUniform('u_count', parseFloat(value));
            document.getElementById('particleCountValue').textContent = value;
        }

        function setMetaballStyle(style) {
            const styles = { liquid: 0, glow: 1, neon: 2, chrome: 3 };
            shaders.metaball.setUniform('u_style', styles[style]);
            updateActiveButton(event.target);
        }

        function setMetaballThreshold(value) {
            shaders.metaball.setUniform('u_threshold', parseFloat(value));
            document.getElementById('metaThresholdValue').textContent = value;
        }

        function setKaleidoSegments(segments) {
            shaders.kaleido.setUniform('u_segments', segments);
            updateActiveButton(event.target);
        }

        function setKaleidoRotation(value) {
            shaders.kaleido.setUniform('u_rotation', parseFloat(value));
            document.getElementById('kaleidoRotValue').textContent = value;
        }

        function setRaymarchScene(scene) {
            const scenes = { spheres: 0, torus: 1, mandelbulb: 2, menger: 3 };
            shaders.raymarch.setUniform('u_scene', scenes[scene]);
            updateActiveButton(event.target);
        }

        function setRaymarchSteps(value) {
            shaders.raymarch.setUniform('u_steps', parseFloat(value));
            document.getElementById('raymarchStepsValue').textContent = value;
        }

        function setGradientType(type) {
            const types = { rainbow: 0, sunset: 1, aurora: 2, galaxy: 3 };
            shaders.gradient.setUniform('u_type', types[type]);
            updateActiveButton(event.target);
        }

        function setGradientComplexity(value) {
            shaders.gradient.setUniform('u_complexity', parseFloat(value));
            document.getElementById('gradComplexValue').textContent = value;
        }

        function updateActiveButton(button) {
            if (!button) return;
            const buttons = button.parentElement.querySelectorAll('.control-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
        }

        // Animation loop
        function animate() {
            for (const shader of Object.values(shaders)) {
                if (shader && shader.render) {
                    shader.render();
                }
            }
            requestAnimationFrame(animate);
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            initShaders();
            animate();
        });
    </script>
</body>
</html>
